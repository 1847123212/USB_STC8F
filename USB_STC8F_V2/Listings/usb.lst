C51 COMPILER V9.59.0.0   USB                                                               10/08/2019 17:47:47 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE USB
OBJECT MODULE PLACED IN .\Objects\usb.obj
COMPILER INVOKED BY: C:\Program Files\Keil C\C51\C51\BIN\C51.EXE USB\Src\usb.c OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Us
                    -er\Inc;.\Drivers\Inc;.\USB\Inc) DEBUG PRINT(.\Listings\usb.lst) TABS(2) OBJECT(.\Objects\usb.obj)

line level    source

   1          
   2          // Written By : Thanh Tung
   3          // E-Mail     : electricthanhtung@gmail.com
   4          // Facebook   : https://www.facebook.com/electricthanhtung
   5          
   6          #include "main.h"
   7          #include "usb.h"
   8          #include "usb_desc.h"
   9          
  10          volatile unsigned char data usb_rx_buffer[12];
  11          volatile unsigned char xdata usb_tx_buffer[12];
  12          volatile unsigned char data usb_tx_count = 0, usb_rx_count = 0;
  13          volatile unsigned char data UEPF = 1, UDRF = 1;
  14          volatile unsigned char xdata USB_TimerTick = 0;   // 20ms
  15          static volatile unsigned char xdata rx_buffer[250];
  16          static unsigned char xdata data_sync;
  17          
  18          static data struct usb_type{
  19            volatile unsigned char state;
  20            volatile unsigned char event;
  21            volatile unsigned char device_address;
  22            
  23            volatile unsigned char received;
  24            volatile unsigned char ack;
  25            
  26            unsigned char endpoint;
  27            
  28            volatile unsigned int wLength;
  29          } usb = {0, 0, 0, 0, 0, 0, 0xFF};
  30          
  31          extern void usb_send_ack();
  32          extern void usb_send_nack();
  33          
  34          static void usb_send_answer(){
  35   1        extern void usb_tx();
  36   1        P3 = (P3 & 0xFC) | 0x01;
  37   1        P3M0 |= 0x03;
  38   1        P3M1 &= ~0x03;
  39   1        usb_tx();
  40   1        P3M0 &= ~0x03;
  41   1        P3M1 |= 0x03;
  42   1      }
  43          
  44          static void usb_received_reentrant() reentrant {
  45   1        static unsigned char data data_count = 0, pid_data_old;
  46   1        UDRF = 0;
  47   1        if(usb_rx_buffer[1] == USB_PID_OUT){
  48   2          unsigned char address = usb_rx_buffer[2] & 0x7F;
  49   2          if((address == usb.device_address) || (address == 0)){
  50   3            usb.state = USB_STATE_OUT;
  51   3            usb.endpoint = usb_rx_buffer[2] >> 7;
  52   3            usb.endpoint |= ((usb_rx_buffer[3] & 0x07) << 1);
  53   3          }
  54   2        }
C51 COMPILER V9.59.0.0   USB                                                               10/08/2019 17:47:47 PAGE 2   

  55   1        else if(usb_rx_buffer[1] == USB_PID_SETUP){
  56   2          //usb.state = USB_STATE_SETUP;
  57   2          unsigned char address = usb_rx_buffer[2] & 0x7F;
  58   2          if((address == usb.device_address) || (address == 0)){
  59   3            usb.state = USB_STATE_SETUP;
  60   3            usb.endpoint = usb_rx_buffer[2] >> 7;
  61   3            usb.endpoint |= ((usb_rx_buffer[3] & 0x07) << 1);
  62   3          }
  63   2          return;
  64   2        }
  65   1        else switch(usb_rx_buffer[1]){
  66   2        case USB_PID_IN:{
  67   3          unsigned char address = usb_rx_buffer[2] & 0x7F;
  68   3          if((address != usb.device_address) && (address != 0))
  69   3            return;
  70   3          if(usb_tx_count){
  71   4            usb_send_answer();
  72   4            usb_tx_count = 0;
  73   4          }
  74   3      //    if(usb.event == USB_EVENT_READY_DATA_IN){
  75   3      //      usb_send_answer();
  76   3      //      usb.event = USB_EVENT_WAIT_DATA_IN;
  77   3      //    }
  78   3          else
  79   3            usb_send_nack();
  80   3          usb.state = USB_STATE_IN;
  81   3          break;
  82   3        }
  83   2        case USB_PID_DATA0:{
  84   3          if(usb.state == USB_STATE_OUT){
  85   4            if(pid_data_old == USB_PID_DATA1){
  86   5              unsigned char xdata *buffer = &rx_buffer[data_count];
  87   5              buffer[0] = usb_rx_buffer[2];
  88   5              buffer[1] = usb_rx_buffer[3];
  89   5              buffer[2] = usb_rx_buffer[4];
  90   5              buffer[3] = usb_rx_buffer[5];
  91   5              buffer[4] = usb_rx_buffer[6];
  92   5              buffer[5] = usb_rx_buffer[7];
  93   5              buffer[6] = usb_rx_buffer[8];
  94   5              buffer[7] = usb_rx_buffer[9];
  95   5              usb_send_ack();
  96   5              data_count += 8;
  97   5              if(data_count >= usb.wLength){
  98   6                usb.received = 1;
  99   6                usb_tx_count = 0;
 100   6                UDRF = 1;
 101   6              }
 102   5              pid_data_old = USB_PID_DATA0;
 103   5            }
 104   4            else{
 105   5              delay_us(1);
 106   5              usb_send_ack();
 107   5            }
 108   4            usb.event = USB_EVENT_NO;
 109   4          }
 110   3          else{
 111   4            rx_buffer[2] = usb_rx_buffer[2];
 112   4            rx_buffer[3] = usb_rx_buffer[3];
 113   4            rx_buffer[4] = usb_rx_buffer[4];
 114   4            rx_buffer[5] = usb_rx_buffer[5];
 115   4            rx_buffer[6] = usb_rx_buffer[6];
 116   4            rx_buffer[7] = usb_rx_buffer[7];
C51 COMPILER V9.59.0.0   USB                                                               10/08/2019 17:47:47 PAGE 3   

 117   4            rx_buffer[8] = usb_rx_buffer[8];
 118   4            pid_data_old = USB_PID_DATA0;
 119   4            data_count = 0;
 120   4            usb.event = USB_EVENT_RECEIVE_SETUP_DATA;
 121   4            if((usb_rx_buffer[2] == 0x21) && (usb_rx_buffer[3] == 0x09))
 122   4              UDRF = 0;
 123   4            else
 124   4              UDRF = 1;
 125   4            //UDRF = 1;
 126   4            usb_send_ack();
 127   4            
 128   4      //      wLength = usb_rx_buffer[9];
 129   4      //      wLength = (wLength << 8) | usb_rx_buffer[8];
 130   4            
 131   4            usb.wLength = usb_rx_buffer[8];
 132   4          }
 133   3          break;
 134   3        }
 135   2        case USB_PID_DATA1:
 136   2          if (usb.state == USB_STATE_OUT){
 137   3            if(usb_rx_count > 4){
 138   4              if(pid_data_old == USB_PID_DATA0){
 139   5                unsigned char xdata *buffer = &rx_buffer[data_count];
 140   5                buffer[0] = usb_rx_buffer[2];
 141   5                buffer[1] = usb_rx_buffer[3];
 142   5                buffer[2] = usb_rx_buffer[4];
 143   5                buffer[3] = usb_rx_buffer[5];
 144   5                buffer[4] = usb_rx_buffer[6];
 145   5                buffer[5] = usb_rx_buffer[7];
 146   5                buffer[6] = usb_rx_buffer[8];
 147   5                buffer[7] = usb_rx_buffer[9];
 148   5                usb_send_ack();
 149   5                data_count += 8;
 150   5                if(data_count >= usb.wLength){
 151   6                  usb.received = 1;
 152   6                  usb_tx_count = 0;
 153   6                  UDRF = 1;
 154   6                }
 155   5                pid_data_old = USB_PID_DATA1;
 156   5              }
 157   4              else{
 158   5                delay_us(1);
 159   5                usb_send_ack();
 160   5              }
 161   4              usb.event = USB_EVENT_NO;
 162   4            }
 163   3            else{
 164   4              usb_tx_count = 0;
 165   4              delay_us(1);
 166   4              usb.state = USB_STATE_IDLE;
 167   4              usb_send_ack();
 168   4            }
 169   3          }
 170   2          break;
 171   2        case USB_PID_ACK:
 172   2          usb.ack = 1;
 173   2          break;
 174   2        case USB_PID_NACK:
 175   2          break;
 176   2        default:
 177   2          usb.state = USB_STATE_IDLE;
 178   2          break;
C51 COMPILER V9.59.0.0   USB                                                               10/08/2019 17:47:47 PAGE 4   

 179   2        }
 180   1      }
 181          
 182          void usb_received() {
 183   1        usb_received_reentrant();
 184   1      }
 185          
 186          static const unsigned char code usb_report_null[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
 187          
 188          const unsigned int code table[] = {
 189            0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241,
 190            0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,
 191            0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40,
 192            0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841,
 193            0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40,
 194            0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41,
 195            0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641,
 196            0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040,
 197            0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240,
 198            0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441,
 199            0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41,
 200            0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840,
 201            0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41,
 202            0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,
 203            0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640,
 204            0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041,
 205            0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240,
 206            0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,
 207            0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41,
 208            0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840,
 209            0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41,
 210            0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40,
 211            0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640,
 212            0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041,
 213            0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241,
 214            0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,
 215            0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40,
 216            0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,
 217            0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40,
 218            0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,
 219            0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641,
 220            0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040
 221          };
 222          
 223          void usb_calc_crc16(unsigned char length) reentrant {
 224   1        unsigned int crc = 0xFFFF;
 225   1        unsigned char i = 2;
 226   1        while(length--){
 227   2          crc = table[(crc ^ usb_tx_buffer[i]) & 0xFF] ^ (crc >> 8);
 228   2          i++;
 229   2        }
 230   1        crc = ~crc;
 231   1        usb_tx_buffer[i] = crc;
 232   1        usb_tx_buffer[i + 1] = crc >> 8;
 233   1      }
 234          
 235          //static void usb_calc_crc16(unsigned char length){
 236          //  unsigned int data crc = 0xFFFF;
 237          //  unsigned char data index;
 238          //  for(index = 0; index < length; index++){
 239          //    unsigned char data i;
 240          //    crc ^= usb_tx_buffer[index + 2];
C51 COMPILER V9.59.0.0   USB                                                               10/08/2019 17:47:47 PAGE 5   

 241          //    for (i = 8; i--;){
 242          //      if (crc & 0x01){
 243          //        crc >>= 1;
 244          //        crc ^= 0xA001;
 245          //      }
 246          //      else
 247          //        crc >>= 1;
 248          //    }
 249          //  }
 250          //  crc = ~crc;
 251          //  usb_tx_buffer[index + 2] = (unsigned char)crc;
 252          //  usb_tx_buffer[index + 3] = (unsigned char)(crc >> 8);
 253          //}
 254          
 255          void USB_SendData(unsigned char *buffer, unsigned char length) reentrant {
 256   1        unsigned char timeStart;
 257   1        usb.state = USB_STATE_IN;
 258   1        usb_tx_buffer[0] = 0x80;
 259   1        data_sync = USB_PID_DATA1;
 260   1        while (length > 0){
 261   2          usb_tx_buffer[1] = data_sync;
 262   2          if (data_sync == USB_PID_DATA1)
 263   2            data_sync = USB_PID_DATA0;
 264   2          else
 265   2            data_sync = USB_PID_DATA1;
 266   2          if(length >= 8){
 267   3            unsigned char i;
 268   3            for(i = 0; i < 8; i++)
 269   3              usb_tx_buffer[i + 2] = buffer[i];
 270   3            buffer += 8;
 271   3            usb_calc_crc16(8);
 272   3            usb_tx_count = 12;
 273   3            length -= 8;
 274   3          }
 275   2          else{
 276   3            unsigned char i;
 277   3            for(i = 2; i < (length + 2); i++)
 278   3              usb_tx_buffer[i] = *buffer++;
 279   3            usb_calc_crc16(length);
 280   3            usb_tx_count = length + 4;
 281   3            length = 0;
 282   3          }
 283   2          
 284   2          timeStart = USB_TimerTick;
 285   2          while(usb_tx_count){
 286   3            if((usb.state != USB_STATE_IN) || ((unsigned char)(USB_TimerTick - timeStart) > (100 / TimerTickStep)))
             -{
 287   4              usb_tx_count = 0;
 288   4              return;
 289   4            }
 290   3          }
 291   2          
 292   2      //    usb.event = USB_EVENT_READY_DATA_IN;
 293   2      //    while(usb.event != USB_EVENT_WAIT_DATA_IN);
 294   2        }
 295   1      }
 296          
 297          void USB_WriteBuf(unsigned char *buffer, unsigned char length) reentrant {
 298   1        unsigned char start = 0;
 299   1        unsigned char timeStart;
 300   1        usb_tx_buffer[0] = 0x80;
 301   1        data_sync = USB_PID_DATA1;
C51 COMPILER V9.59.0.0   USB                                                               10/08/2019 17:47:47 PAGE 6   

 302   1        while (length > 0){
 303   2          usb_tx_buffer[1] = data_sync;
 304   2          if (data_sync == USB_PID_DATA1)
 305   2            data_sync = USB_PID_DATA0;
 306   2          else
 307   2            data_sync = USB_PID_DATA1;
 308   2          
 309   2          if(!start){
 310   3            start = 1;
 311   3            usb_tx_buffer[2] = length;
 312   3            
 313   3            if((length % 8) == 7)
 314   3              length++;
 315   3            
 316   3            if(length >= 7){
 317   4              unsigned char i;
 318   4              for(i = 0; i < 7; i++)
 319   4                usb_tx_buffer[i + 3] = buffer[i];
 320   4              buffer += 7;
 321   4              usb_calc_crc16(8);
 322   4              usb_tx_count = 12;
 323   4              length -= 7;
 324   4            }
 325   3            else{
 326   4              unsigned char i;
 327   4              for(i = 3; i < (length + 3); i++)
 328   4                usb_tx_buffer[i] = *buffer++;
 329   4              usb_calc_crc16(length + 1);
 330   4              usb_tx_count = length + 5;
 331   4              length = 0;
 332   4            }
 333   3          }
 334   2          else if(length >= 8){
 335   3            unsigned char i;
 336   3            for(i = 0; i < 8; i++)
 337   3              usb_tx_buffer[i + 2] = buffer[i];
 338   3            buffer += 8;
 339   3            usb_calc_crc16(8);
 340   3            usb_tx_count = 12;
 341   3            length -= 8;
 342   3          }
 343   2          else{
 344   3            unsigned char data i;
 345   3            for(i = 2; i < (length + 2); i++)
 346   3              usb_tx_buffer[i] = *buffer++;
 347   3            usb_calc_crc16(length);
 348   3            usb_tx_count = length + 4;
 349   3            length = 0;
 350   3          }
 351   2          
 352   2          timeStart = USB_TimerTick;
 353   2          while(usb_tx_count){
 354   3            if((unsigned char)(USB_TimerTick - timeStart) > (100 / TimerTickStep)){
 355   4              usb_tx_count = 0;
 356   4              return;
 357   4            }
 358   3          }
 359   2          
 360   2        }
 361   1        TR0 = 0;
 362   1      }
 363          
C51 COMPILER V9.59.0.0   USB                                                               10/08/2019 17:47:47 PAGE 7   

 364          static void USB_SendNull(unsigned char PID_DATA) reentrant {
 365   1        unsigned char timeStart;
 366   1        usb.state = USB_STATE_IN;
 367   1        usb_tx_buffer[0] = 0x80;
 368   1        usb_tx_buffer[1] = PID_DATA;
 369   1        usb_tx_buffer[2] = 0;
 370   1        usb_tx_buffer[3] = 0;
 371   1        usb_tx_count = 4;
 372   1        
 373   1        timeStart = USB_TimerTick;
 374   1        while(usb_tx_count){
 375   2          if((usb.state != USB_STATE_IN) || ((unsigned char)(USB_TimerTick - timeStart) > (100 / TimerTickStep))){
 376   3            usb_tx_count = 0;
 377   3            return;
 378   3          }
 379   2        }
 380   1      }
 381          
 382          static void usb_send_stall() {
 383   1        usb_tx_buffer[0] = 0x80;
 384   1        usb_tx_buffer[1] = USB_PID_STALL;
 385   1        usb_tx_count = 2;
 386   1      }
 387          
 388          void USB_Process() {
 389   1        if(usb.event == USB_EVENT_RECEIVE_SETUP_DATA){
 390   2          usb.event = USB_EVENT_NO;
 391   2          if(rx_buffer[2] == USBRQ_STD_FROM_DEVICE){
 392   3            if(rx_buffer[3] == USBRQ_GET_DESCRIPTOR){
 393   4              switch(rx_buffer[5]){
 394   5              case USBDESCR_DEVICE:
 395   5                USB_SendData((unsigned char *)usb_device_descriptor, ARRAY_LENGHT(usb_device_descriptor));
 396   5                break;
 397   5              case USBDESCR_CONFIG:
 398   5                if(rx_buffer[8] < ARRAY_LENGHT(usb_configuration_descriptor))
 399   5                  USB_SendData((unsigned char *)usb_configuration_descriptor, rx_buffer[8]);
 400   5                else
 401   5                  USB_SendData((unsigned char *)usb_configuration_descriptor, ARRAY_LENGHT(usb_configuration_descripto
             -r));
 402   5                break;
 403   5              case USBDESCR_STRING:
 404   5                if(rx_buffer[4] == 0){
 405   6                  USB_SendData((unsigned char *)usb_string_descriptor_language, ARRAY_LENGHT(usb_string_descriptor_lan
             -guage));
 406   6                  USB_SendNull(data_sync);
 407   6                }
 408   5                else if(rx_buffer[4] == 1){
 409   6                  USB_SendData((unsigned char *)usb_string_descriptor_vendor, ARRAY_LENGHT(usb_string_descriptor_vendo
             -r));
 410   6                  USB_SendNull(data_sync);
 411   6                }
 412   5                else if(rx_buffer[4] == 2){
 413   6                  USB_SendData((unsigned char *)usb_string_descriptor_device, ARRAY_LENGHT(usb_string_descriptor_devic
             -e));
 414   6                  USB_SendNull(data_sync);
 415   6                }
 416   5                else if(rx_buffer[4] == 3){
 417   6                  USB_SendData((unsigned char *)usb_string_descriptor_serial, ARRAY_LENGHT(usb_string_descriptor_seria
             -l));
 418   6                  USB_SendNull(data_sync);
 419   6                }
 420   5                else
C51 COMPILER V9.59.0.0   USB                                                               10/08/2019 17:47:47 PAGE 8   

 421   5                  USB_SendNull(USB_PID_DATA1);
 422   5                break;
 423   5              default:
 424   5                  break;
 425   5              }
 426   4            }
 427   3            else if(rx_buffer[3] == USBRQ_GET_STATUS){
 428   4              usb_send_stall();
 429   4            }
 430   3          }
 431   2          else if(rx_buffer[2] == USBRQ_STD_TO_DEVICE){
 432   3            switch(rx_buffer[3]){
 433   4              case USBRQ_SET_ADDRESS:
 434   4                if(usb.device_address != 0){
 435   5                  //
 436   5                }
 437   4                USB_SendNull(USB_PID_DATA1);
 438   4                usb.device_address = rx_buffer[4];
 439   4                break;
 440   4              case (USBRQ_SET_CONFIGURATION):
 441   4                USB_SendNull(USB_PID_DATA1);
 442   4                break;
 443   4            }
 444   3          }
 445   2          else if (rx_buffer[2] == USBRQ_STD_FROM_INTERFACE){
 446   3            if(rx_buffer[3] == USBRQ_GET_DESCRIPTOR)
 447   3              USB_SendData((unsigned char *)usb_report_descriptor, ARRAY_LENGHT(usb_report_descriptor));
 448   3          }
 449   2          else if(rx_buffer[2] == USBRQ_CLASS_TO_INTERFACE){
 450   3            if(rx_buffer[3] == 0x0A)
 451   3              usb_send_stall();
 452   3          }
 453   2          else if(rx_buffer[2] == USBRQ_CLASS_FROM_INTERFACE)
 454   2            USB_SendData((unsigned char *)usb_report_null, ARRAY_LENGHT(usb_report_null));
 455   2        }
 456   1        if(usb.received){
 457   2          extern void USB_Received(unsigned char endpoint, unsigned char *buffer, unsigned char length) reentrant;
 458   2          unsigned char xdata timeStart;
 459   2          usb.ack = 0;
 460   2          USB_SendNull(USB_PID_DATA1);
 461   2          timeStart = USB_TimerTick;
 462   2          usb.received = 0;
 463   2          usb.event = USB_EVENT_NO;
 464   2          while(!usb.ack){
 465   3            if((unsigned char)(USB_TimerTick - timeStart) > 5)
 466   3              return;
 467   3          }
 468   2          USB_Received(usb.endpoint, rx_buffer, usb.wLength);
 469   2        }
 470   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2186    ----
   CONSTANT SIZE    =    709    ----
   XDATA SIZE       =    264       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     26    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
C51 COMPILER V9.59.0.0   USB                                                               10/08/2019 17:47:47 PAGE 9   

   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
