C51 COMPILER V9.59.0.0   USB                                                               08/14/2019 10:40:36 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE USB
OBJECT MODULE PLACED IN .\Objects\usb.obj
COMPILER INVOKED BY: C:\Program Files\Keil C\C51\C51\BIN\C51.EXE USB\Src\usb.c OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Us
                    -er\Inc;.\Drivers\Inc;.\USB\Inc) DEBUG PRINT(.\Listings\usb.lst) TABS(2) OBJECT(.\Objects\usb.obj)

line level    source

   1          
   2          // Written By : Thanh Tung
   3          // E-Mail     : electricthanhtung@gmail.com
   4          // Facebook   : https://www.facebook.com/electricthanhtung
   5          
   6          #include "main.h"
   7          #include "usb.h"
   8          #include "usb_desc.h"
   9          
  10          volatile unsigned char data usb_rx_buffer[16];
  11          volatile unsigned char xdata usb_tx_buffer[16];
  12          volatile unsigned char xdata rx_buffer[16];
  13          volatile unsigned char data usb_tx_count = 0, usb_rx_count = 0;
  14          volatile unsigned char data UEPF = 1, UDRF = 1;
  15          volatile unsigned int xdata USB_TimerTick = 0;    // 20ms
  16          
  17          static data struct usb_type{
  18            volatile unsigned char state;
  19            volatile unsigned char event;
  20            volatile unsigned char device_address;
  21            
  22            volatile unsigned char received;
  23            volatile unsigned char ack;
  24            
  25            unsigned char endpoint;
  26            unsigned char setup_endpoint;
  27            
  28            unsigned int wLength;
  29          } usb = {0, 0, 0, 0, 0, 0, 0, 0xFF};
  30          
  31          static unsigned char xdata usb_data[250];
  32          
  33          extern void usb_send_ack();
  34          extern void usb_send_nack();
  35          
  36          static void usb_send_answer(){
  37   1        extern void usb_tx();
  38   1        P3 = (P3 & 0xFC) | 0x01;
  39   1        P3M0 |= 0x03;
  40   1        P3M1 &= ~0x03;
  41   1        usb_tx();
  42   1        P3M0 &= ~0x03;
  43   1        P3M1 |= 0x03;
  44   1      }
  45          
  46          static void usb_received_reentrant() reentrant {
  47   1        static unsigned char data data_count = 0, pid_data_old;
  48   1        UDRF = 0;
  49   1        if(usb_rx_buffer[1] == USB_PID_OUT){
  50   2          unsigned char address = usb_rx_buffer[2] & 0x7F;
  51   2          if((address == usb.device_address) || (address == 0)){
  52   3            usb.state = USB_STATE_OUT;
  53   3            usb.endpoint = usb_rx_buffer[2] >> 7;
  54   3            usb.endpoint |= ((usb_rx_buffer[3] & 0x07) << 1);
C51 COMPILER V9.59.0.0   USB                                                               08/14/2019 10:40:36 PAGE 2   

  55   3          }
  56   2        }
  57   1        else if(usb_rx_buffer[1] == USB_PID_SETUP){
  58   2          //usb.state = USB_STATE_SETUP;
  59   2          unsigned char address = usb_rx_buffer[2] & 0x7F;
  60   2          if((address == usb.device_address) || (address == 0)){
  61   3            usb.state = USB_STATE_SETUP;
  62   3            usb.endpoint = usb_rx_buffer[2] >> 7;
  63   3            usb.endpoint |= ((usb_rx_buffer[3] & 0x07) << 1);
  64   3          }
  65   2          return;
  66   2        }
  67   1        else switch(usb_rx_buffer[1]){
  68   2        case USB_PID_IN:{
  69   3          unsigned char address = usb_rx_buffer[2] & 0x7F;
  70   3          if((address != usb.device_address) && (address != 0))
  71   3            return;
  72   3          if(usb_tx_count){
  73   4            usb_send_answer();
  74   4            usb_tx_count = 0;
  75   4          }
  76   3      //    if(usb.event == USB_EVENT_READY_DATA_IN){
  77   3      //      usb_send_answer();
  78   3      //      usb.event = USB_EVENT_WAIT_DATA_IN;
  79   3      //    }
  80   3          else
  81   3            usb_send_nack();
  82   3          usb.state = USB_STATE_IN;
  83   3          break;
  84   3        }
  85   2        case USB_PID_DATA0:{
  86   3          if(usb.state == USB_STATE_OUT){
  87   4            if(pid_data_old == USB_PID_DATA1){
  88   5              unsigned char *buffer = &usb_data[data_count];
  89   5              buffer[0] = usb_rx_buffer[2];
  90   5              buffer[1] = usb_rx_buffer[3];
  91   5              buffer[2] = usb_rx_buffer[4];
  92   5              buffer[3] = usb_rx_buffer[5];
  93   5              buffer[4] = usb_rx_buffer[6];
  94   5              buffer[5] = usb_rx_buffer[7];
  95   5              usb_send_ack();
  96   5              buffer[6] = usb_rx_buffer[8];
  97   5              buffer[7] = usb_rx_buffer[9];
  98   5              data_count += 8;
  99   5              if(data_count >= usb.wLength){
 100   6                usb.received = 1;
 101   6                usb_tx_count = 0;
 102   6                UDRF = 1;
 103   6              }
 104   5              pid_data_old = USB_PID_DATA0;
 105   5            }
 106   4            else{
 107   5              delay_us(1);
 108   5              usb_send_ack();
 109   5            }
 110   4            usb.event = USB_EVENT_NO;
 111   4          }
 112   3          else if(usb.state == USB_STATE_SETUP){
 113   4            rx_buffer[2] = usb_rx_buffer[2];
 114   4            rx_buffer[3] = usb_rx_buffer[3];
 115   4            rx_buffer[4] = usb_rx_buffer[4];
 116   4            rx_buffer[5] = usb_rx_buffer[5];
C51 COMPILER V9.59.0.0   USB                                                               08/14/2019 10:40:36 PAGE 3   

 117   4            rx_buffer[6] = usb_rx_buffer[6];
 118   4            rx_buffer[7] = usb_rx_buffer[7];
 119   4            rx_buffer[8] = usb_rx_buffer[8];
 120   4            
 121   4            usb_send_ack();
 122   4            
 123   4      //      wLength = usb_rx_buffer[9];
 124   4      //      wLength = (wLength << 8) | usb_rx_buffer[8];
 125   4            
 126   4            usb.wLength = usb_rx_buffer[8];
 127   4            pid_data_old = USB_PID_DATA0;
 128   4            data_count = 0;
 129   4            usb.event = USB_EVENT_RECEIVE_SETUP_DATA;
 130   4            UDRF = 1;
 131   4          }
 132   3          break;
 133   3        }
 134   2        case USB_PID_DATA1:
 135   2          if (usb.state == USB_STATE_OUT){
 136   3            if(usb_rx_count > 4){
 137   4              if(pid_data_old == USB_PID_DATA0){
 138   5                unsigned char *buffer = &usb_data[data_count];
 139   5                buffer[0] = usb_rx_buffer[2];
 140   5                buffer[1] = usb_rx_buffer[3];
 141   5                buffer[2] = usb_rx_buffer[4];
 142   5                buffer[3] = usb_rx_buffer[5];
 143   5                buffer[4] = usb_rx_buffer[6];
 144   5                buffer[5] = usb_rx_buffer[7];
 145   5                usb_send_ack();
 146   5                buffer[6] = usb_rx_buffer[8];
 147   5                buffer[7] = usb_rx_buffer[9];
 148   5                data_count += 8;
 149   5                if(data_count >= usb.wLength){
 150   6                  usb.received = 1;
 151   6                  usb_tx_count = 0;
 152   6                  UDRF = 1;
 153   6                }
 154   5                pid_data_old = USB_PID_DATA1;
 155   5              }
 156   4              else{
 157   5                delay_us(1);
 158   5                usb_send_ack();
 159   5              }
 160   4              usb.event = USB_EVENT_NO;
 161   4            }
 162   3            else{
 163   4              usb_tx_count = 0;
 164   4              delay_us(1);
 165   4              usb_send_ack();
 166   4            }
 167   3          }
 168   2          break;
 169   2        case USB_PID_ACK:
 170   2          usb.ack = 1;
 171   2          break;
 172   2        case USB_PID_NACK:
 173   2          break;
 174   2        default:
 175   2          usb.state = USB_STATE_IDLE;
 176   2          break;
 177   2        }
 178   1      }
C51 COMPILER V9.59.0.0   USB                                                               08/14/2019 10:40:36 PAGE 4   

 179          
 180          void usb_received() {
 181   1        usb_received_reentrant();
 182   1      }
 183          
 184          static const unsigned char code usb_report_null[] = {
 185            0x00,
 186            0x00,
 187            0x00,
 188            0x00,
 189            0x00,
 190            0x00,
 191            0x00,
 192            0x00,
 193          };
 194          
 195          static const unsigned char code usb_string_descriptor_language[] = {
 196            4,
 197            USBDESCR_STRING,
 198            0x09, 0x04,
 199          };
 200          
 201          const unsigned int code table[] = {
 202            0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241,
 203            0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,
 204            0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40,
 205            0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841,
 206            0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40,
 207            0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41,
 208            0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641,
 209            0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040,
 210            0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240,
 211            0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441,
 212            0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41,
 213            0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840,
 214            0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41,
 215            0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,
 216            0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640,
 217            0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041,
 218            0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240,
 219            0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,
 220            0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41,
 221            0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840,
 222            0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41,
 223            0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40,
 224            0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640,
 225            0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041,
 226            0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241,
 227            0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,
 228            0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40,
 229            0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,
 230            0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40,
 231            0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,
 232            0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641,
 233            0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040
 234          };
 235          
 236          void usb_calc_crc16(unsigned char length) reentrant {
 237   1        unsigned int crc = 0xFFFF;
 238   1        unsigned char i = 2;
 239   1        while(length--){
 240   2          crc = table[(crc ^ usb_tx_buffer[i]) & 0xFF] ^ (crc >> 8);
C51 COMPILER V9.59.0.0   USB                                                               08/14/2019 10:40:36 PAGE 5   

 241   2          i++;
 242   2        }
 243   1        crc = ~crc;
 244   1        usb_tx_buffer[i] = crc;
 245   1        usb_tx_buffer[i + 1] = crc >> 8;
 246   1      }
 247          
 248          //static void usb_calc_crc16(unsigned char length){
 249          //  unsigned int data crc = 0xFFFF;
 250          //  unsigned char data index;
 251          //  for(index = 0; index < length; index++){
 252          //    unsigned char data i;
 253          //    crc ^= usb_tx_buffer[index + 2];
 254          //    for (i = 8; i--;){
 255          //      if (crc & 0x01){
 256          //        crc >>= 1;
 257          //        crc ^= 0xA001;
 258          //      }
 259          //      else
 260          //        crc >>= 1;
 261          //    }
 262          //  }
 263          //  crc = ~crc;
 264          //  usb_tx_buffer[index + 2] = (unsigned char)crc;
 265          //  usb_tx_buffer[index + 3] = (unsigned char)(crc >> 8);
 266          //}
 267          
 268          static unsigned char xdata data_sync;
 269          
 270          void USB_SendData(unsigned char *buffer, unsigned char length, unsigned char mode) reentrant {
 271   1        unsigned int timeStart;
 272   1        
 273   1        usb_tx_buffer[0] = 0x80;
 274   1        usb.state = USB_STATE_IN;
 275   1        if(mode)
 276   1          data_sync = USB_PID_DATA1;
 277   1        while (length > 0){
 278   2          usb_tx_buffer[1] = data_sync;
 279   2          if (data_sync == USB_PID_DATA1)
 280   2            data_sync = USB_PID_DATA0;
 281   2          else
 282   2            data_sync = USB_PID_DATA1;
 283   2          if(length >= 8){
 284   3            unsigned char i;
 285   3            for(i = 0; i < 8; i++)
 286   3              usb_tx_buffer[i + 2] = buffer[i];
 287   3            buffer += 8;
 288   3            usb_calc_crc16(8);
 289   3            usb_tx_count = 12;
 290   3            length -= 8;
 291   3          }
 292   2          else{
 293   3            unsigned char i;
 294   3            for(i = 2; i < (length + 2); i++)
 295   3              usb_tx_buffer[i] = *buffer++;
 296   3            usb_calc_crc16(length);
 297   3            usb_tx_count = length + 4;
 298   3            length = 0;
 299   3          }
 300   2          
 301   2          timeStart = USB_TimerTick;
 302   2          while(usb_tx_count){
C51 COMPILER V9.59.0.0   USB                                                               08/14/2019 10:40:36 PAGE 6   

 303   3            if(usb.state != USB_STATE_IN){
 304   4              usb_tx_count = 0;
 305   4              return;
 306   4            }
 307   3            if((unsigned int)(USB_TimerTick - timeStart) > (100 / TimerTickStep)){
 308   4              usb_tx_count = 0;
 309   4              return;
 310   4            }
 311   3          }
 312   2          
 313   2      //    usb.event = USB_EVENT_READY_DATA_IN;
 314   2      //    while(usb.event != USB_EVENT_WAIT_DATA_IN);
 315   2        }
 316   1      }
 317          
 318          void USB_WriteBuf(unsigned char *buffer, unsigned char length) reentrant {
 319   1        unsigned char start = 0;
 320   1        unsigned int timeStart;
 321   1        usb_tx_buffer[0] = 0x80;
 322   1        data_sync = USB_PID_DATA1;
 323   1        while (length > 0){
 324   2          usb_tx_buffer[1] = data_sync;
 325   2          if (data_sync == USB_PID_DATA1)
 326   2            data_sync = USB_PID_DATA0;
 327   2          else
 328   2            data_sync = USB_PID_DATA1;
 329   2          
 330   2          if(!start){
 331   3            start = 1;
 332   3            usb_tx_buffer[2] = length;
 333   3            
 334   3            if((length % 8) == 7)
 335   3              length++;
 336   3            
 337   3            if(length >= 7){
 338   4              unsigned char i;
 339   4              for(i = 0; i < 7; i++)
 340   4                usb_tx_buffer[i + 3] = buffer[i];
 341   4              buffer += 7;
 342   4              usb_calc_crc16(8);
 343   4              usb_tx_count = 12;
 344   4              length -= 7;
 345   4            }
 346   3            else{
 347   4              unsigned char i;
 348   4              for(i = 3; i < (length + 3); i++)
 349   4                usb_tx_buffer[i] = *buffer++;
 350   4              usb_calc_crc16(length + 1);
 351   4              usb_tx_count = length + 5;
 352   4              length = 0;
 353   4            }
 354   3          }
 355   2          else if(length >= 8){
 356   3            unsigned char i;
 357   3            for(i = 0; i < 8; i++)
 358   3              usb_tx_buffer[i + 2] = buffer[i];
 359   3            buffer += 8;
 360   3            usb_calc_crc16(8);
 361   3            usb_tx_count = 12;
 362   3            length -= 8;
 363   3          }
 364   2          else{
C51 COMPILER V9.59.0.0   USB                                                               08/14/2019 10:40:36 PAGE 7   

 365   3            unsigned char data i;
 366   3            for(i = 2; i < (length + 2); i++)
 367   3              usb_tx_buffer[i] = *buffer++;
 368   3            usb_calc_crc16(length);
 369   3            usb_tx_count = length + 4;
 370   3            length = 0;
 371   3          }
 372   2          
 373   2          timeStart = USB_TimerTick;
 374   2          while(usb_tx_count){
 375   3            if((unsigned int)(USB_TimerTick - timeStart) > (100 / TimerTickStep)){
 376   4              usb_tx_count = 0;
 377   4              return;
 378   4            }
 379   3          }
 380   2          
 381   2        }
 382   1        TR0 = 0;
 383   1      }
 384          
 385          static void USB_SendNull() reentrant {
 386   1        unsigned int timeStart;
 387   1        usb.state = USB_STATE_IN;
 388   1        usb_tx_buffer[0] = 0x80;
 389   1        usb_tx_buffer[1] = USB_PID_DATA1;
 390   1        usb_tx_buffer[2] = 0;
 391   1        usb_tx_buffer[3] = 0;
 392   1        usb_tx_count = 4;
 393   1        
 394   1        timeStart = USB_TimerTick;
 395   1        while(usb_tx_count){
 396   2          if(usb.state != USB_STATE_IN){
 397   3            usb_tx_count = 0;
 398   3            return;
 399   3          }
 400   2          if((unsigned int)(USB_TimerTick - timeStart) > (100 / TimerTickStep)){
 401   3            usb_tx_count = 0;
 402   3            return;
 403   3          }
 404   2        }
 405   1      }
 406          
 407          static void usb_send_stall() {
 408   1        usb_tx_buffer[0] = 0x80;
 409   1        usb_tx_buffer[1] = USB_PID_STALL;
 410   1        usb_tx_count = 2;
 411   1      }
 412          
 413          void USB_Process() {
 414   1        extern void usb_exit_process();
 415   1        if(usb.event == USB_EVENT_RECEIVE_SETUP_DATA){
 416   2          usb.event = USB_EVENT_NO;
 417   2          if(rx_buffer[2] == USBRQ_STD_FROM_DEVICE){
 418   3            if(rx_buffer[3] == USBRQ_GET_DESCRIPTOR){
 419   4              switch (rx_buffer[5]){
 420   5              case USBDESCR_DEVICE:
 421   5                USB_SendData((unsigned char *)usb_device_descriptor, ARRAY_LENGHT(usb_device_descriptor), 1);
 422   5                break;
 423   5              case USBDESCR_CONFIG:
 424   5                if(rx_buffer[8] < ARRAY_LENGHT(usb_configuration_descriptor))
 425   5                  USB_SendData((unsigned char *)usb_configuration_descriptor, rx_buffer[8], 1);
 426   5                else
C51 COMPILER V9.59.0.0   USB                                                               08/14/2019 10:40:36 PAGE 8   

 427   5                  USB_SendData((unsigned char *)usb_configuration_descriptor, ARRAY_LENGHT(usb_configuration_descripto
             -r), 1);
 428   5                break;
 429   5              case USBDESCR_STRING:
 430   5                if(rx_buffer[4] == 0)
 431   5                  USB_SendData((unsigned char *)usb_string_descriptor_language, ARRAY_LENGHT(usb_string_descriptor_lan
             -guage), 1);
 432   5                else if(rx_buffer[4] == 1)
 433   5                  USB_SendData((unsigned char *)usb_string_descriptor_vendor, ARRAY_LENGHT(usb_string_descriptor_vendo
             -r), 1);
 434   5                else if(rx_buffer[4] == 2)
 435   5                  USB_SendData((unsigned char *)usb_string_descriptor_device, ARRAY_LENGHT(usb_string_descriptor_devic
             -e), 1);
 436   5                else if(rx_buffer[4] == 3)
 437   5                  USB_SendData((unsigned char *)usb_string_descriptor_serial, ARRAY_LENGHT(usb_string_descriptor_seria
             -l), 1);
 438   5                USB_SendNull();
 439   5                break;
 440   5              default:
 441   5                  break;
 442   5              }
 443   4            }
 444   3            else if(rx_buffer[3] == USBRQ_GET_STATUS){
 445   4              usb_send_stall();
 446   4            }
 447   3          }
 448   2          else if(rx_buffer[2] == USBRQ_STD_TO_DEVICE){
 449   3            switch (rx_buffer[3]){
 450   4              case USBRQ_SET_ADDRESS:
 451   4                if(usb.device_address != 0){
 452   5                  //
 453   5                }
 454   4                USB_SendNull();
 455   4                usb.device_address = rx_buffer[4];
 456   4                break;
 457   4              case (USBRQ_SET_CONFIGURATION):
 458   4                USB_SendNull();
 459   4                break;
 460   4            }
 461   3          }
 462   2          else if (rx_buffer[2] == USBRQ_STD_FROM_INTERFACE){
 463   3            if (rx_buffer[3] == USBRQ_GET_DESCRIPTOR)
 464   3              USB_SendData((unsigned char *)usb_report_descriptor, ARRAY_LENGHT(usb_report_descriptor), 1);
 465   3          }
 466   2          else if (rx_buffer[2] == USBRQ_CLASS_TO_INTERFACE){
 467   3            if(rx_buffer[3] == 0x0A)
 468   3              usb_send_stall();
 469   3          }
 470   2          else if(rx_buffer[2] == USBRQ_CLASS_FROM_INTERFACE)
 471   2            USB_SendData((unsigned char *)usb_report_null, ARRAY_LENGHT(usb_report_null), 1);
 472   2        }
 473   1        if(usb.received){
 474   2          extern void USB_Received(unsigned char *buffer, unsigned char length) reentrant;
 475   2          unsigned int xdata timeStart;
 476   2          usb.ack = 0;
 477   2          USB_SendNull();
 478   2          timeStart = USB_TimerTick;
 479   2          usb.received = 0;
 480   2          usb.event = USB_EVENT_NO;
 481   2          while(!usb.ack){
 482   3            if((unsigned int)(USB_TimerTick - timeStart) > 5)
 483   3              usb_exit_process();
C51 COMPILER V9.59.0.0   USB                                                               08/14/2019 10:40:36 PAGE 9   

 484   3          }
 485   2          USB_Received(usb_data, usb.wLength);
 486   2        }
 487   1        usb_exit_process();
 488   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2280    ----
   CONSTANT SIZE    =    709    ----
   XDATA SIZE       =    285       2
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     31    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
